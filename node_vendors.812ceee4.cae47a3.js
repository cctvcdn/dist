(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{195:function(t,e,s){"use strict";s.d(e,"a",(function(){return k})),s.d(e,"b",(function(){return S})),s.d(e,"c",(function(){return P})),s.d(e,"d",(function(){return x}));var r=s(300),i=s(198),o=s(446),n=s(447),a=s(231);const h=t=>null==t,c=t=>!h(t),u=(t,e,s)=>g(e,t)===g(s,t);function l(t){return t&&t.length&&RegExp("^\\/([a-zA-Z0-9@\\-%_~.:][/a-zA-Z0-9@\\-%_~.:]*)?([?][^#]*)?(#[^#]*)?$").test(t)}function p(t,e,s){return t.matched.some((t=>Object.values(t.components).some((t=>t.options&&t.options[e]===s))))}function g(t="",e){let s=t.split("?")[0];return e&&e.base&&(s=s.replace(e.base,"/")),"/"===s.charAt(s.length-1)&&(s=s.slice(0,-1)),s=s.replace(/\/+/g,"/"),s}function d(t){return"string"==typeof t?t:JSON.stringify(t)}function f(t){if("string"==typeof t)try{return JSON.parse(t)}catch(e){}return t}function m(t,e){if(!e||!t||"object"!=typeof t)return t;if(e in t)return t[e];const s=Array.isArray(e)?e:(e+"").split(".");let r=t;for(;s.length&&r;)r=r[s.shift()];return r}class y{constructor(t,e){this.ctx=t,this.options=e,this._initState()}setUniversal(t,e){return h(e)?this.removeUniversal(t):(this.setCookie(t,e),this.setLocalStorage(t,e),this.setState(t,e),e)}getUniversal(t){let e;return h(e)&&(e=this.getCookie(t)),h(e)&&(e=this.getLocalStorage(t)),h(e)&&(e=this.getState(t)),e}syncUniversal(t,e){let s=this.getUniversal(t);return h(s)&&c(e)&&(s=e),c(s)&&this.setUniversal(t,s),s}removeUniversal(t){this.removeState(t),this.removeLocalStorage(t),this.removeCookie(t)}_initState(){if(i.set(this,"_state",{}),this._useVuex=this.options.vuex&&!!this.ctx.store,this._useVuex){const t={namespaced:!0,state:()=>this.options.initialState,mutations:{SET(t,e){i.set(t,e.key,e.value)}}};this.ctx.store.registerModule(this.options.vuex.namespace,t,{preserveState:!!this.ctx.store.state[this.options.vuex.namespace]}),this.state=this.ctx.store.state[this.options.vuex.namespace]}else i.set(this,"state",{})}setState(t,e){return"_"===t[0]?i.set(this._state,t,e):this._useVuex?this.ctx.store.commit(this.options.vuex.namespace+"/SET",{key:t,value:e}):i.set(this.state,t,e),e}getState(t){return"_"!==t[0]?this.state[t]:this._state[t]}watchState(t,e){if(this._useVuex)return this.ctx.store.watch((e=>m(e[this.options.vuex.namespace],t)),e)}removeState(t){this.setState(t,void 0)}setLocalStorage(t,e){if(h(e))return this.removeLocalStorage(t);if(!this.isLocalStorageEnabled())return;const s=this.getPrefix()+t;try{localStorage.setItem(s,d(e))}catch(r){if(!this.options.ignoreExceptions)throw r}return e}getLocalStorage(t){if(!this.isLocalStorageEnabled())return;const e=this.getPrefix()+t;return f(localStorage.getItem(e))}removeLocalStorage(t){if(!this.isLocalStorageEnabled())return;const e=this.getPrefix()+t;localStorage.removeItem(e)}getCookies(){if(!this.isCookiesEnabled())return;const t=document.cookie;return o.parse(t||"")||{}}setCookie(t,e,s={}){if(!this.options.cookie)return;if(!this.isCookiesEnabled())return;const r=(void 0!==s.prefix?s.prefix:this.options.cookie.prefix)+t,i=Object.assign({},this.options.cookie.options,s),n=d(e);h(e)&&(i.maxAge=-1),"number"==typeof i.expires&&(i.expires=new Date(Date.now()+864e5*i.expires));const a=o.serialize(r,n,i);return document.cookie=a,e}getCookie(t){if(!this.options.cookie)return;if(!this.isCookiesEnabled())return;const e=this.options.cookie.prefix+t,s=this.getCookies();return f(s[e]?decodeURIComponent(s[e]):void 0)}removeCookie(t,e){this.setCookie(t,void 0,e)}getPrefix(){if(!this.options.localStorage)throw Error("Cannot get prefix; localStorage is off");return this.options.localStorage.prefix}isLocalStorageEnabled(){if(!this.options.localStorage)return!1;const t="test";try{return localStorage.setItem(t,t),localStorage.removeItem(t),!0}catch(e){return this.options.ignoreExceptions,!1}}isCookiesEnabled(){return!!this.options.cookie&&!!window.navigator.cookieEnabled}}class k{constructor(t,e){this.strategies={},this._errorListeners=[],this._redirectListeners=[],this.ctx=t,this.options=e;const s=new y(t,{...e,initialState:{user:null,loggedIn:!1}});this.$storage=s,this.$state=s.state}get state(){return this._stateWarnShown||(this._stateWarnShown=!0),this.$state}get strategy(){return this.getStrategy()}getStrategy(t=!0){if(t){if(!this.$state.strategy)throw Error("No strategy is set!");if(!this.strategies[this.$state.strategy])throw Error("Strategy not supported: "+this.$state.strategy)}return this.strategies[this.$state.strategy]}get user(){return this.$state.user}get loggedIn(){return this.$state.loggedIn}get busy(){return this.$storage.getState("busy")}async init(){if(this.options.resetOnError&&this.onError(((...t)=>{("function"!=typeof this.options.resetOnError||this.options.resetOnError(...t))&&this.reset()})),this.$storage.syncUniversal("strategy",this.options.defaultStrategy),!this.getStrategy(!1)&&(this.$storage.setUniversal("strategy",this.options.defaultStrategy),!this.getStrategy(!1)))return Promise.resolve();try{await this.mounted()}catch(t){this.callOnError(t)}finally{this.options.watchLoggedIn&&this.$storage.watchState("loggedIn",(t=>{p(this.ctx.route,"auth",!1)||this.redirect(t?"home":"logout")}))}}getState(t){return this._getStateWarnShown||(this._getStateWarnShown=!0),this.$storage.getState(t)}registerStrategy(t,e){this.strategies[t]=e}setStrategy(t){if(t===this.$storage.getUniversal("strategy"))return Promise.resolve();if(!this.strategies[t])throw Error(`Strategy ${t} is not defined!`);return this.reset(),this.$storage.setUniversal("strategy",t),this.mounted()}mounted(...t){return this.getStrategy().mounted?Promise.resolve(this.getStrategy().mounted(...t)).catch((t=>(this.callOnError(t,{method:"mounted"}),Promise.reject(t)))):this.fetchUserOnce()}loginWith(t,...e){return this.setStrategy(t).then((()=>this.login(...e)))}login(...t){return this.getStrategy().login?this.wrapLogin(this.getStrategy().login(...t)).catch((t=>(this.callOnError(t,{method:"login"}),Promise.reject(t)))):Promise.resolve()}fetchUser(...t){return this.getStrategy().fetchUser?Promise.resolve(this.getStrategy().fetchUser(...t)).catch((t=>(this.callOnError(t,{method:"fetchUser"}),Promise.reject(t)))):Promise.resolve()}logout(...t){return this.getStrategy().logout?Promise.resolve(this.getStrategy().logout(...t)).catch((t=>(this.callOnError(t,{method:"logout"}),Promise.reject(t)))):(this.reset(),Promise.resolve())}setUserToken(t,e){return this.getStrategy().setUserToken?Promise.resolve(this.getStrategy().setUserToken(t,e)).catch((t=>(this.callOnError(t,{method:"setUserToken"}),Promise.reject(t)))):(this.getStrategy().token.set(t),Promise.resolve())}reset(...t){return this.getStrategy().reset||(this.setUser(!1),this.getStrategy().token.reset(),this.getStrategy().refreshToken.reset()),this.getStrategy().reset(...t)}refreshTokens(){return this.getStrategy().refreshController?Promise.resolve(this.getStrategy().refreshController.handleRefresh()).catch((t=>(this.callOnError(t,{method:"refreshTokens"}),Promise.reject(t)))):Promise.resolve()}check(...t){return this.getStrategy().check?this.getStrategy().check(...t):{valid:!0}}fetchUserOnce(...t){return this.$state.user?Promise.resolve():this.fetchUser(...t)}setUser(t){this.$storage.setState("user",t);let e={valid:!!t};e.valid&&(e=this.check()),this.$storage.setState("loggedIn",e.valid)}request(t,e={}){const s="object"==typeof e?Object.assign({},e,t):t;if(""===s.baseURL&&(s.baseURL=r(this.ctx.req)),this.ctx.app.$axios)return this.ctx.app.$axios.request(s).catch((t=>(this.callOnError(t,{method:"request"}),Promise.reject(t))))}requestWith(t,e,s){const r=this.getStrategy().token.get(),i=Object.assign({},s,e),o=this.strategies[t].options.token.name||"Authorization";return i.headers||(i.headers={}),!i.headers[o]&&c(r)&&r&&"string"==typeof r&&(i.headers[o]=r),this.request(i)}wrapLogin(t){return this.$storage.setState("busy",!0),this.error=null,Promise.resolve(t).then((t=>(this.$storage.setState("busy",!1),t))).catch((t=>(this.$storage.setState("busy",!1),Promise.reject(t))))}onError(t){this._errorListeners.push(t)}callOnError(t,e={}){this.error=t;for(const s of this._errorListeners)s(t,e)}redirect(t,e=!1){if(!this.options.redirect)return;const s=this.options.fullPathRedirect?this.ctx.route.fullPath:this.ctx.route.path;let r=this.options.redirect[t];if(r){if(this.options.rewriteRedirects&&("login"===t&&l(s)&&!u(this.ctx,r,s)&&this.$storage.setUniversal("redirect",s),"home"===t)){const t=this.$storage.getUniversal("redirect");this.$storage.setUniversal("redirect",null),l(t)&&(r=t)}r=this.callOnRedirect(r,s)||r,u(this.ctx,r,s)||(e?(l(r)&&!r.includes(this.ctx.base)&&(r=g("/"+this.ctx.base+"/"+r)),window.location.replace(r)):this.ctx.redirect(r,this.ctx.query))}}onRedirect(t){this._redirectListeners.push(t)}callOnRedirect(t,e){for(const s of this._redirectListeners)t=s(t,e)||t;return t}hasScope(t){const e=this.$state.user&&m(this.$state.user,this.options.scopeKey);return!!e&&(Array.isArray(e)?e.includes(t):!!m(e,t))}}const x=async t=>{if(p(t.route,"auth",!1))return;if(!function(t,e=[]){return[].concat(...t.matched.map((function(t,s){return Object.keys(t.components).map((function(r){return e.push(s),t.components[r]}))})))}(t.route,[]).length)return;const{login:e,callback:s}=t.$auth.options.redirect,r=p(t.route,"auth","guest"),i=e=>g(t.route.path,t)===g(e,t);if(t.$auth.$state.loggedIn){const{tokenExpired:s,refreshTokenExpired:n,isRefreshable:a}=t.$auth.check(!0);if((!e||i(e)||r)&&t.$auth.redirect("home"),n)t.$auth.reset();else if(s)if(a)try{await t.$auth.refreshTokens()}catch(o){t.$auth.reset()}else t.$auth.reset()}else r||s&&i(s)||t.$auth.redirect("login")};class S extends Error{constructor(){super("Both token and refresh token have expired. Your request was aborted."),this.name="ExpiredAuthSessionError"}}var v,$;($=v||(v={})).UNKNOWN="UNKNOWN",$.VALID="VALID",$.EXPIRED="EXPIRED";class E{constructor(t,e){this._status=this._calculate(t,e)}unknown(){return v.UNKNOWN===this._status}valid(){return v.VALID===this._status}expired(){return v.EXPIRED===this._status}_calculate(t,e){const s=Date.now();try{if(!t||!e)return v.UNKNOWN}catch(r){return v.UNKNOWN}return(e-=500)>s?v.VALID:v.EXPIRED}}class _{constructor(t,e){this.scheme=t,this.axios=e,this.interceptor=null}setHeader(t){this.scheme.options.token.global&&this.axios.setHeader(this.scheme.options.token.name,t)}clearHeader(){this.scheme.options.token.global&&this.axios.setHeader(this.scheme.options.token.name,!1)}initializeRequestInterceptor(t){this.interceptor=this.axios.interceptors.request.use((async e=>{if(!this._needToken(e)||e.url===t)return e;const{valid:s,tokenExpired:r,refreshTokenExpired:i,isRefreshable:o}=this.scheme.check(!0);let n=s;if(i)throw this.scheme.reset(),new S;if(r){if(!o)throw this.scheme.reset(),new S;n=await this.scheme.refreshTokens().then((()=>!0)).catch((()=>{throw this.scheme.reset(),new S}))}const a=this.scheme.token.get();if(!n){if(!a&&this._requestHasAuthorizationHeader(e))throw new S;return e}return this._getUpdatedRequestConfig(e,a)}))}reset(){this.axios.interceptors.request.eject(this.interceptor),this.interceptor=null}_needToken(t){const e=this.scheme.options;return e.token.global||Object.values(e.endpoints).some((e=>"object"==typeof e?e.url===t.url:e===t.url))}_getUpdatedRequestConfig(t,e){return"string"==typeof e&&(t.headers[this.scheme.options.token.name]=e),t}_requestHasAuthorizationHeader(t){return!!t.headers.common[this.scheme.options.token.name]}}class U{constructor(t,e){this.scheme=t,this.$storage=e}get(){const t=this.scheme.options.token.prefix+this.scheme.name;return this.$storage.getUniversal(t)}set(t){const e=function(t,e){return t&&e&&"string"==typeof t&&!t.startsWith(e)?e+" "+t:t}(t,this.scheme.options.token.type);return this._setToken(e),this._updateExpiration(e),"string"==typeof e&&this.scheme.requestHandler.setHeader(e),e}sync(){const t=this._syncToken();return this._syncExpiration(),"string"==typeof t&&this.scheme.requestHandler.setHeader(t),t}reset(){this.scheme.requestHandler.clearHeader(),this._setToken(!1),this._setExpiration(!1)}status(){return new E(this.get(),this._getExpiration())}_getExpiration(){const t=this.scheme.options.token.expirationPrefix+this.scheme.name;return this.$storage.getUniversal(t)}_setExpiration(t){const e=this.scheme.options.token.expirationPrefix+this.scheme.name;return this.$storage.setUniversal(e,t)}_syncExpiration(){const t=this.scheme.options.token.expirationPrefix+this.scheme.name;return this.$storage.syncUniversal(t)}_updateExpiration(t){let e;const s=Date.now(),r=1e3*Number(this.scheme.options.token.maxAge),i=r?s+r:0;try{e=1e3*a(t+"").exp||i}catch(o){if(e=i,!o||"InvalidTokenError"!==o.name)throw o}return this._setExpiration(e||!1)}_setToken(t){const e=this.scheme.options.token.prefix+this.scheme.name;return this.$storage.setUniversal(e,t)}_syncToken(){const t=this.scheme.options.token.prefix+this.scheme.name;return this.$storage.syncUniversal(t)}}class w{constructor(t,...e){this.$auth=t,this.options=e.reduce(((t,e)=>n(t,e)),{})}get name(){return this.options.name}}const b={name:"local",endpoints:{login:{url:"/api/auth/login",method:"post"},logout:{url:"/api/auth/logout",method:"post"},user:{url:"/api/auth/user",method:"get"}},token:{property:"token",type:"Bearer",name:"Authorization",maxAge:1800,global:!0,required:!0,prefix:"_token.",expirationPrefix:"_token_expiration."},user:{property:"user",autoFetch:!0},clientId:!1,grantType:!1,scope:!1};class P extends w{constructor(t,e,...s){super(t,e,...s,b),this.token=new U(this,this.$auth.$storage),this.requestHandler=new _(this,this.$auth.ctx.$axios)}check(t=!1){const e={valid:!1,tokenExpired:!1};return this.token.sync()?t&&this.token.status().expired()?(e.tokenExpired=!0,e):(e.valid=!0,e):e}mounted({tokenCallback:t=()=>this.$auth.reset(),refreshTokenCallback:e}={}){const{tokenExpired:s,refreshTokenExpired:r}=this.check(!0);return r&&"function"==typeof e?e():s&&"function"==typeof t&&t(),this.initializeRequestInterceptor(),this.$auth.fetchUserOnce()}async login(t,{reset:e=!0}={}){if(!this.options.endpoints.login)return;e&&this.$auth.reset({resetInterceptor:!1}),this.options.clientId&&(t.data.client_id=this.options.clientId),this.options.grantType&&(t.data.grant_type=this.options.grantType),this.options.scope&&(t.data.scope=this.options.scope);const s=await this.$auth.request(t,this.options.endpoints.login);return this.updateTokens(s),this.requestHandler.interceptor||this.initializeRequestInterceptor(),this.options.user.autoFetch&&await this.fetchUser(),s}setUserToken(t){return this.token.set(t),this.fetchUser()}fetchUser(t){return this.check().valid?this.options.endpoints.user?this.$auth.requestWith(this.name,t,this.options.endpoints.user).then((t=>{const e=m(t.data,this.options.user.property);if(!e){const t=Error("User Data response does not contain field "+this.options.user.property);return Promise.reject(t)}return this.$auth.setUser(e),t})).catch((t=>(this.$auth.callOnError(t,{method:"fetchUser"}),Promise.reject(t)))):(this.$auth.setUser({}),Promise.resolve()):Promise.resolve()}async logout(t={}){return this.options.endpoints.logout&&await this.$auth.requestWith(this.name,t,this.options.endpoints.logout).catch((()=>{})),this.$auth.reset()}reset({resetInterceptor:t=!0}={}){this.$auth.setUser(!1),this.token.reset(),t&&this.requestHandler.reset()}updateTokens(t){const e=!this.options.token.required||m(t.data,this.options.token.property);this.token.set(e)}initializeRequestInterceptor(){this.requestHandler.initializeRequestInterceptor()}}},851:function(t,e,s){!function(t){t.installComponents=function(t,s){var r="function"==typeof t.exports?t.exports.extendOptions:t.options;for(var i in"function"==typeof t.exports&&(r.components=t.exports.options.components),r.components=r.components||{},s)r.components[i]=r.components[i]||s[i];r.functional&&function(t,s){if(!t.exports[e]){t.exports[e]=!0;var r=t.exports.render;t.exports.render=function(t,e){return r(t,Object.assign({},e,{_c:function(t,r,i){return e._c(s[t]||t,r,i)}}))}}}(t,r.components)};var e="_functionalComponents"}(s(73))}}]);